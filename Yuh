local UIS = game:GetService("UserInputService")

-- Create the FOV circle
local fovCircle = Drawing.new("Circle")
fovCircle.Position = Vector2.new(workspace.CurrentCamera.ViewportSize.X / 2, workspace.CurrentCamera.ViewportSize.Y / 2)
fovCircle.Radius = 100 -- Adjust the radius as needed
fovCircle.Thickness = 2
fovCircle.Color = Color3.new(1, 0, 0) -- Red color
fovCircle.Filled = false
fovCircle.Visible = true

-- Maximum distance for targeting
local maxDistance = 200 -- Adjust as needed

-- Toggle state and locked target
local silentAimEnabled = false
local lockedTarget = nil

-- Create a toggle button
local screenGui = Instance.new("ScreenGui")
local toggleButton = Instance.new("TextButton")

screenGui.Parent = game.Players.LocalPlayer:WaitForChild("PlayerGui")

toggleButton.Size = UDim2.new(0, 100, 0, 50)
toggleButton.Position = UDim2.new(0, 10, 0.5, -25) -- Left side of the screen
toggleButton.BackgroundColor3 = Color3.new(0, 0, 0)
toggleButton.TextColor3 = Color3.new(1, 1, 1)
toggleButton.Text = "Enable Silent Aim"
toggleButton.Parent = screenGui

toggleButton.MouseButton1Click:Connect(function()
    silentAimEnabled = not silentAimEnabled
    if silentAimEnabled and not lockedTarget then
        lockedTarget = getClosestPlayerInFOV() -- Lock onto the first target
    else
        lockedTarget = nil -- Unlock target when disabling
    end
    toggleButton.Text = silentAimEnabled and "Disable Silent Aim" or "Enable Silent Aim"
end)

-- Function to get the closest player within the FOV circle and distance
function getClosestPlayerInFOV()
    local players = game.Players:GetPlayers()
    local localPlayer = game.Players.LocalPlayer
    local closestPlayer = nil
    local shortestDistance = math.huge

    for _, player in pairs(players) do
        if player ~= localPlayer and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
            local character = player.Character
            local humanoidRootPart = character.HumanoidRootPart
            local screenPoint = workspace.CurrentCamera:WorldToScreenPoint(humanoidRootPart.Position)
            local fovCenter = Vector2.new(workspace.CurrentCamera.ViewportSize.X / 2, workspace.CurrentCamera.ViewportSize.Y / 2)
            local distance = (Vector2.new(screenPoint.X, screenPoint.Y) - fovCenter).magnitude
            local actualDistance = (localPlayer.Character.HumanoidRootPart.Position - humanoidRootPart.Position).magnitude

            if distance < fovCircle.Radius and distance < shortestDistance and actualDistance <= maxDistance then
                closestPlayer = player
                shortestDistance = distance
            end
        end
    end

    return closestPlayer
end

-- Function to predict the future position of the target
function predictTargetPosition(target, predictionTime)
    if target and target.Character and target.Character:FindFirstChild("HumanoidRootPart") then
        local targetPos = target.Character.HumanoidRootPart.Position
        local targetVelocity = target.Character.HumanoidRootPart.Velocity
        return targetPos + targetVelocity * predictionTime
    end
    return nil
end

-- Function to adjust aiming direction with prediction
function silentAim()
    if silentAimEnabled and lockedTarget then
        local predictionTime = 0.6 -- Adjust prediction time as needed
        local predictedPos = predictTargetPosition(lockedTarget, predictionTime)
        if predictedPos then
            local cam = workspace.CurrentCamera
            cam.CFrame = CFrame.new(cam.CFrame.Position, predictedPos)
        end
    end
end

-- Continuous silent aim
game:GetService("RunService").RenderStepped:Connect(function()
    silentAim()
end)
